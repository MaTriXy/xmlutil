/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.09.24 at 08:12:58 PM CEST
//


package nl.adaptivity.xml.serialization.regressions.soap

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.SerializationException
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.buildClassSerialDescriptor
import kotlinx.serialization.descriptors.element
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.encoding.decodeStructure
import kotlinx.serialization.encoding.encodeStructure
import nl.adaptivity.serialutil.decodeElements
import nl.adaptivity.xmlutil.*
import nl.adaptivity.xmlutil.core.impl.multiplatform.name
import nl.adaptivity.xmlutil.serialization.XML
import nl.adaptivity.xmlutil.serialization.XmlSerialName
import nl.adaptivity.xmlutil.serialization.XmlValue
import nl.adaptivity.xmlutil.util.CompactFragmentSerializer
import nl.adaptivity.xmlutil.util.ICompactFragment
import kotlin.jvm.JvmStatic

/**
 *
 *
 * Java class for Envelope complex type.
 *
 *
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * ```
 * <complexType name="Envelope">
 * <complexContent>
 * <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 * <sequence>
 * <element ref="{http://www.w3.org/2003/05/soap-envelope}Header" minOccurs="0"/>
 * <element ref="{http://www.w3.org/2003/05/soap-envelope}Body"/>
 * </sequence>
 * <anyAttribute processContents='lax' namespace='##other'/>
 * </restriction>
 * </complexContent>
 * </complexType>
 * ```
 *
 * @property otherAttributes A map that contains attributes that aren't bound to any typed property
 *                   on this class.
 *                   the map is keyed by the name of the attribute and the value is the string value
 *                   of the attribute. the map returned by this method is live, and you can add new
 *                   attribute by updating the map directly. Because of this design, there's no
 *                   setter.
 */
@Serializable(Envelope.Serializer::class)
class Envelope<T : Any>(
    val body: Body<T>,
    val header: Header = Header(),
    val otherAttributes: Map<QName, String> = emptyMap(),
) {

    val elementName: QName
        get() = ELEMENTNAME

    constructor(content: T) : this(Body<T>(content))

    public class Serializer<T : Any>(bodyContentSerializer: KSerializer<T>) : /*Xml*/KSerializer<Envelope<T>> {
        private val bodySerializer: KSerializer<Body<T>> = Body.Serializer(bodyContentSerializer)

        @OptIn(XmlUtilInternal::class)
        override val descriptor: SerialDescriptor =
            buildClassSerialDescriptor(Envelope::class.name, bodyContentSerializer.descriptor) {
                annotations = SoapSerialObjects.envelopeAnnotations
                element("otherAttributes", SoapSerialObjects.attrsSerializer.descriptor, isOptional = true)
                element<Header>("header", isOptional = true)
                element("body", bodySerializer.descriptor)
            }

        override fun deserialize(decoder: Decoder): Envelope<T> {
            var header = Header()
            lateinit var body: Body<T>
            var otherAttributes: Map<QName, String> = mutableMapOf()
            var encodingStyle: String? = null

            decoder.decodeStructure(descriptor) {
                decodeElements(this) { idx ->
                    when (idx) {
                        0 -> otherAttributes =
                            decodeSerializableElement(descriptor, idx, SoapSerialObjects.attrsSerializer)

                        1 -> header = decodeSerializableElement(descriptor, idx, Header.serializer())
                        2 -> body = decodeSerializableElement(descriptor, idx, bodySerializer)
                    }
                }
            }
            return Envelope(body, header, otherAttributes)
        }

        fun deserializeXML(
            decoder: Decoder,
            input: XmlReader,
            previousValue: Envelope<T>?,
            isValueChild: Boolean
        ): Envelope<T> {
            var header = Header()
            lateinit var body: Body<T>
            var otherAttributes: Map<QName, String> = mutableMapOf()
            var encodingStyle: String? = null
            input.require(EventType.START_ELEMENT, NAMESPACE, ELEMENTLOCALNAME)
            otherAttributes = input.attributes.filter {
                when {
                    it.prefix == XMLConstants.XMLNS_ATTRIBUTE ||
                            (it.prefix == "" && it.localName == XMLConstants.XMLNS_ATTRIBUTE) -> false

                    it.namespaceUri != NAMESPACE -> true
                    it.localName == "encodingStyle" -> {
                        encodingStyle = it.value; false
                    }

                    else -> true
                }
            }.associate { QName(it.namespaceUri, it.localName, it.prefix) to it.value }

            input.require(EventType.START_ELEMENT, NAMESPACE, ELEMENTLOCALNAME)
            decoder.decodeStructure(descriptor) {
                do {
                    when {
                        input.eventType == EventType.START_ELEMENT -> {
                            when {
                                input.namespaceURI != NAMESPACE -> input.skipElement() // ignore but process
                                input.localName == Header.ELEMENTLOCALNAME ->
                                    header = decoder.decodeSerializableValue(Header.serializer())

                                input.localName == Body.ELEMENTLOCALNAME ->
                                    body = decoder.decodeSerializableValue(bodySerializer)

                                else -> input.skipElement() // Ignore again
                            }
                        }

                        input.eventType.isIgnorable -> input.next()

                        else -> throw SerializationException("Found unexpected event in xml stream")
                    }

                } while (input.eventType != EventType.END_ELEMENT)
            }

            encodingStyle?.let { s ->
                if (body.encodingStyle == null) {
                    body = body.copy(encodingStyle = s)
                }
            }
            return Envelope(body, header, otherAttributes)
        }

        override fun serialize(encoder: Encoder, value: Envelope<T>) {
            encoder.encodeStructure(descriptor) {
                encodeSerializableElement(
                    descriptor,
                    0,
                    SoapSerialObjects.attrsSerializer,
                    value.otherAttributes
                )
                if (value.header.blocks.isNotEmpty() || value.header.otherAttributes.isNotEmpty()) {
                    encodeSerializableElement(descriptor, 1, Header.serializer(), value.header)
                }
                encodeSerializableElement(descriptor, 2, bodySerializer, value.body)
            }
        }

        fun serializeXML(encoder: Encoder, output: XmlWriter, value: Envelope<T>, isValueChild: Boolean) {
            val writer: XmlWriter = output
            encoder.encodeStructure(descriptor) {
                for ((aName, aValue) in value.otherAttributes) {
                    val prefixForNs = when (aName.namespaceURI) {
                        "" -> ""
                        else -> writer.getPrefix(aName.namespaceURI)
                    } ?: run {
                        writer.namespaceAttr(aName.prefix, aName.namespaceURI)
                        aName.prefix
                    }
                    writer.attribute(aName.namespaceURI, aName.localPart, prefixForNs, aValue)
                }
                (encoder as XML.XmlOutput).delegateFormat().encodeToWriter(writer, bodySerializer, value.body)
            }
        }
    }

    companion object {

        const val NAMESPACE = "http://www.w3.org/2003/05/soap-envelope"

        const val ELEMENTLOCALNAME = "Envelope"

        const val PREFIX = "soap"

        val ELEMENTNAME = QName(NAMESPACE, ELEMENTLOCALNAME, PREFIX)

        const val MIMETYPE = "application/soap+xml"

        @JvmStatic
        fun deserialize(reader: XmlReader): Envelope<out ICompactFragment> {
            return XML { indent = 2; autoPolymorphic = true }.decodeFromReader(
                serializer(CompactFragmentSerializer),
                reader
            )
        }

    }

}

internal object SoapSerialObjects {

    val envelopeAnnotations = listOf(XmlSerialName(Envelope.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX))

    val headerAnnotations = listOf(XmlSerialName(Header.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX))

    val bodyAnnotations = listOf(XmlSerialName(Body.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX))

    val encodingStyleAnnotations = listOf(XmlSerialName("encodingStyle", Envelope.NAMESPACE, Envelope.PREFIX))

    val valueAnnotations = listOf(XmlValue(true))

    object attrsSerializer : KSerializer<Map<QName, String>> {
        private val default = MapSerializer(QNameSerializer, String.serializer())

        override val descriptor: SerialDescriptor = SerialDescriptor("attrsSerializer", default.descriptor)

        override fun deserialize(decoder: Decoder): Map<QName, String> {
            return if (decoder is XML.XmlInput) {
                decoder.input.attributes
                    .asSequence()
                    .filter { !(it.prefix == "xmlns" || (it.prefix == "" && it.localName == "xmlns")) }
                    .associate { QName(it.namespaceUri, it.localName, it.prefix) to it.value }
                    .toMap()
            } else {
                default.deserialize(decoder)
            }
        }

        override fun serialize(encoder: Encoder, value: Map<QName, String>) {
            if (encoder is XML.XmlOutput) {
                val out = encoder.target
                for ((name, aValue) in value) {
                    out.attribute(name.namespaceURI, name.localPart, name.prefix, aValue)
                }
            } else {
                default.serialize(encoder, value)
            }
        }
    }

}
