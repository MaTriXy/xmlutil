/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.09.24 at 08:12:58 PM CEST
//


package nl.adaptivity.xml.serialization.regressions.soap

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.buildClassSerialDescriptor
import kotlinx.serialization.descriptors.element
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.encoding.decodeStructure
import kotlinx.serialization.encoding.encodeStructure
import nl.adaptivity.serialutil.decodeElements
import nl.adaptivity.xmlutil.*
import nl.adaptivity.xmlutil.serialization.XML
import nl.adaptivity.xmlutil.serialization.XmlOtherAttributes
import nl.adaptivity.xmlutil.serialization.XmlSerialName
import nl.adaptivity.xmlutil.serialization.XmlValue
import nl.adaptivity.xmlutil.util.CompactFragment
import nl.adaptivity.xmlutil.util.CompactFragmentSerializer
import kotlin.jvm.JvmStatic

/**
 *
 *
 * Java class for Envelope complex type.
 *
 *
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * ```
 * <complexType name="Envelope">
 * <complexContent>
 * <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 * <sequence>
 * <element ref="{http://www.w3.org/2003/05/soap-envelope}Header" minOccurs="0"/>
 * <element ref="{http://www.w3.org/2003/05/soap-envelope}Body"/>
 * </sequence>
 * <anyAttribute processContents='lax' namespace='##other'/>
 * </restriction>
 * </complexContent>
 * </complexType>
 * ```
 *
 * @property otherAttributes A map that contains attributes that aren't bound to any typed property
 *                   on this class.
 *                   the map is keyed by the name of the attribute and the value is the string value
 *                   of the attribute. the map returned by this method is live, and you can add new
 *                   attribute by updating the map directly. Because of this design, there's no
 *                   setter.
 */
@Serializable(Envelope.Serializer::class)
class Envelope<out T : Any>(
    val body: Body<T>,
    val header: Header = Header(),
    val otherAttributes: Map<QName, String> = emptyMap(),
) {

    constructor(content: T) : this(Body<T>(content))

    public class Serializer<T : Any>(bodyContentSerializer: KSerializer<T>) : KSerializer<Envelope<T>> {
        private val bodySerializer: KSerializer<Body<T>> = Body.serializer(bodyContentSerializer)

        @OptIn(ExperimentalSerializationApi::class)
        override val descriptor: SerialDescriptor =
            buildClassSerialDescriptor("org.w3c.dom.Envelope", bodyContentSerializer.descriptor) {
                annotations = listOf(XmlSerialName(ELEMENTLOCALNAME, NAMESPACE, PREFIX))
                element<String>("encodingStyle", SoapSerialObjects.encodingStyleAnnotations, isOptional = true)
                element("otherAttributes", attrsSerializer.descriptor, listOf(XmlOtherAttributes()), isOptional = true)
                element<Header>("header", isOptional = true)
                element("body", bodySerializer.descriptor)
            }

        override fun deserialize(decoder: Decoder): Envelope<T> {
            var header = Header()
            lateinit var body: Body<T>
            var otherAttributes: Map<QName, String> = mutableMapOf()
            var encodingStyle: String? = null

            decoder.decodeStructure(descriptor) {
                decodeElements(this) { idx ->
                    when (idx) {
                        0 -> encodingStyle = decodeStringElement(descriptor, idx)

                        1 -> otherAttributes =
                            decodeSerializableElement(descriptor, idx, attrsSerializer)

                        2 -> header = decodeSerializableElement(descriptor, idx, Header.serializer())
                        3 -> body = decodeSerializableElement(descriptor, idx, bodySerializer)
                    }
                }
            }
            return Envelope(body, header, otherAttributes)
        }

        override fun serialize(encoder: Encoder, value: Envelope<T>) {
            encoder.encodeStructure(descriptor) {
                encodeSerializableElement(descriptor, 1, attrsSerializer, value.otherAttributes)
                if (value.header.blocks.isNotEmpty() || value.header.otherAttributes.isNotEmpty()) {
                    encodeSerializableElement(descriptor, 2, Header.serializer(), value.header)
                }
                encodeSerializableElement(descriptor, 3, bodySerializer, value.body)
            }
        }

    }

    companion object {

        const val NAMESPACE = "http://www.w3.org/2003/05/soap-envelope"

        const val ELEMENTLOCALNAME = "Envelope"

        const val PREFIX = "soap"

        val ELEMENTNAME = QName(NAMESPACE, ELEMENTLOCALNAME, PREFIX)

        const val MIMETYPE = "application/soap+xml"

        @JvmStatic
        private val attrsSerializer = MapSerializer(QNameSerializer, String.serializer())

        @JvmStatic
        fun deserialize(reader: XmlReader): Envelope<CompactFragment> {
            return XML { indent = 2; autoPolymorphic = true }.decodeFromReader(
                serializer(CompactFragmentSerializer),
                reader
            )
        }

    }

}

internal object SoapSerialObjects {

    val headerAnnotations = listOf(XmlSerialName(Header.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX))

    val bodyAnnotations = listOf(XmlSerialName(Body.ELEMENTLOCALNAME, Envelope.NAMESPACE, Envelope.PREFIX))

    val faultAnnotations = listOf(XmlSerialName("Fault", Envelope.NAMESPACE, Envelope.PREFIX))

    val encodingStyleAnnotations = listOf(XmlSerialName("encodingStyle", Envelope.NAMESPACE, Envelope.PREFIX))

    val valueAnnotations = listOf(XmlValue(true))


}
